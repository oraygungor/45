<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Connect the Dots - The Final Challenge</title>
    <style>
        :root {
            --grid-size: 5;
            --dot-size: 20px;
            --gap-size: 60px;
            --dot-color: #95a5a6;
            --path-color: #e74c3c;
            --possible-move-color: #3498db;
            --fail-color: #c0392b;
            --success-color: #27ae60;
            --line-width: 5px;
            --container-width: calc(var(--grid-size) * var(--dot-size) + (var(--grid-size) - 1) * var(--gap-size));
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            height: 100vh; margin: 0; background-color: #ecf0f1;
            -webkit-user-select: none; user-select: none;
        }
        h1 { color: #2c3e50; text-align: center; }
        .instructions {
             text-align:center; max-width: 550px;
             margin: -10px auto 15px auto; line-height: 1.5; color: #34495e;
             border: 1px solid #bdc3c7; padding: 10px; border-radius: 5px; background-color: #fff;
        }
        #puzzle-wrapper { position: relative; width: var(--container-width); height: var(--container-width); }
        #puzzle-grid { display: grid; grid-template-columns: repeat(var(--grid-size), 1fr); grid-template-rows: repeat(var(--grid-size), 1fr); width: 100%; height: 100%; position: relative; z-index: 2; }
        #line-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        .dot { width: var(--dot-size); height: var(--dot-size); background-color: var(--dot-color); border-radius: 50%; margin: auto; cursor: pointer; transition: all 0.15s ease; }
        .dot.path-dot { background-color: var(--path-color); transform: scale(1.2); cursor: not-allowed; }
        .dot.possible-move { background-color: var(--possible-move-color); transform: scale(1.4); box-shadow: 0 0 12px var(--possible-move-color); }
        .line-user { stroke: var(--path-color); stroke-width: var(--line-width); fill: none; stroke-linejoin: round; stroke-linecap: round; }
        .controls { margin-top: 20px; }
        button { padding: 10px 20px; font-size: 16px; border: none; border-radius: 5px; cursor: pointer; margin: 0 5px; background-color: #bdc3c7; color: #2c3e50; transition: all 0.2s; font-weight: bold; }
        button:hover:not(:disabled) { background-color: #7f8c8d; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #status { margin-top: 20px; font-size: 1.2em; font-weight: bold; height: 25px; }
        #angle-info { margin-top: 10px; font-size: 1em; color: #34495e; font-weight: bold; }
        #game-rules-summary {
            margin-top: 20px; padding: 15px; width: 80%; max-width: 500px;
            text-align: center; background-color: #fff; border: 1px dashed #bdc3c7;
            border-radius: 5px; color: #34495e; font-style: italic;
        }
    </style>
</head>
<body>
    <h1>Oray's Dot Puzzle</h1>
    <p class="instructions">
        <strong>Rule:</strong> After a move, you can only go <strong>straight</strong> or make a <strong>"sharp" 45° turn</strong>.<br>
    </p>
    
    <div id="puzzle-wrapper"> <svg id="line-canvas"></svg> <div id="puzzle-grid"></div> </div>
    <p id="status"></p>
    <div id="angle-info">Total Turn Angle: <span id="angle-counter">0</span>°</div>
    <div class="controls">
        <button id="btn-undo">Undo</button>
        <button id="btn-reset">Reset</button>
    </div>
    <div id="game-rules-summary"></div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const gridContainer = document.getElementById('puzzle-grid');
            const lineCanvas = document.getElementById('line-canvas');
            const statusEl = document.getElementById('status');
            const angleCounterEl = document.getElementById('angle-counter');
            const resetButton = document.getElementById('btn-reset');
            const undoButton = document.getElementById('btn-undo');
            const rulesSummaryEl = document.getElementById('game-rules-summary');

            const gridSize = 5;
            const totalDots = gridSize * gridSize;
            let dots = [];
            let currentPath = [];
            let totalAngle = 0;
            let gameActive = true;
            
            function updateRulesSummary() {
                if (!gameActive) {
                    if (currentPath.length === totalDots) {
                        rulesSummaryEl.textContent = "Path complete! You connected all dots without crossing your path.";
                    } else {
                        rulesSummaryEl.textContent = "No more valid moves. The path is stuck. Try using 'Undo' or 'Reset'.";
                    }
                    return;
                }
                
                if (currentPath.length === 0) {
                    rulesSummaryEl.textContent = "Click any dot to begin your path.";
                } else if (currentPath.length === 1) {
                    rulesSummaryEl.textContent = "You've started a path. Any adjacent dot is a valid first move.";
                } else {
                    rulesSummaryEl.textContent = "Follow the path! Only blue dots are valid moves.";
                }
            }

            function endGame(isWin) {
                gameActive = false;
                dots.forEach(d => d.classList.remove('possible-move'));
                if (isWin) {
                    statusEl.textContent = 'Congratulations, you solved it!';
                    statusEl.style.color = 'var(--success-color)';
                } else {
                    statusEl.textContent = `Stuck! You reached ${currentPath.length}/${totalDots} dots.`;
                    statusEl.style.color = 'var(--fail-color)';
                }
                updateRulesSummary();
            }
            
            function updateStatus() {
                if (currentPath.length > 0) {
                    statusEl.textContent = `${currentPath.length} / ${totalDots} dots`;
                    statusEl.style.color = 'var(--path-color)';
                } else {
                    statusEl.textContent = '';
                }
            }

            function resetGame() {
                gameActive = true;
                currentPath = [];
                totalAngle = 0;
                dots.forEach(d => d.className = 'dot');
                lineCanvas.innerHTML = '';
                updateStatus();
                updateButtonStates();
                updateRulesSummary();
                angleCounterEl.textContent = '0';
            }

            function undoMove() {
                if (currentPath.length <= 1) return;
                if (!gameActive) { gameActive = true; }
                const removedDot = currentPath.pop();
                if (currentPath.length >= 2) {
                    const lastDot = currentPath[currentPath.length - 1];
                    const prevDot = currentPath[currentPath.length - 2];
                    const angleDiff = calculateAngle(prevDot, lastDot, removedDot);
                    if (angleDiff === 135) { totalAngle -= 45; }
                }
                removedDot.className = 'dot';
                angleCounterEl.textContent = totalAngle;
                drawLines();
                updateStatus();
                highlightNextMoves();
                updateButtonStates();
                updateRulesSummary();
            }

            // --- Other functions (mostly unchanged logic) ---
            function updateButtonStates() { undoButton.disabled = currentPath.length <= 1; }
            function addDotToPath(dot) {
                if (currentPath.length >= 2) {
                    const lastDot = currentPath[currentPath.length - 1];
                    const prevDot = currentPath[currentPath.length - 2];
                    const angleDiff = calculateAngle(prevDot, lastDot, dot);
                    if (angleDiff === 135) { totalAngle += 45; }
                }
                dot.classList.add('path-dot');
                dot.classList.remove('possible-move');
                currentPath.push(dot);
                drawLines();
                updateStatus();
                updateButtonStates();
                updateRulesSummary();
                angleCounterEl.textContent = totalAngle;
            }
            
            // --- Core Logic (Collapsed for brevity) ---
            function initGrid() { gridContainer.innerHTML = ''; dots = []; for (let r = 0; r < gridSize; r++) for (let c = 0; c < gridSize; c++) { const d = document.createElement('div'); d.className = 'dot'; d.dataset.row = r; d.dataset.col = c; d.addEventListener('click', handleDotClick); gridContainer.appendChild(d); dots.push(d); } }
            function findDot(r, c) { return dots.find(d => d.dataset.row == r && d.dataset.col == c); }
            function handleDotClick(e) { if (!gameActive) return; const t = e.target; if (currentPath.length === 0) { addDotToPath(t); highlightNextMoves(); return; } if (t.classList.contains('possible-move')) { addDotToPath(t); if (currentPath.length === totalDots) { endGame(true); } else { if (!highlightNextMoves()) { endGame(false); } } } }
            function isCrossing(a, b) { if (currentPath.length < 2) return false; const v = getVector(a, b); if (Math.abs(v.dx) !== 1 || Math.abs(v.dy) !== 1) return false; const c = findDot(a.dataset.row, b.dataset.col); const d = findDot(b.dataset.row, a.dataset.col); if (!c || !d) return false; for (let i = 0; i < currentPath.length - 1; i++) { const p1 = currentPath[i], p2 = currentPath[i+1]; if ((p1 === c && p2 === d) || (p1 === d && p2 === c)) return true; } return false; }
            function isAdjacent(d1, d2) { const v = getVector(d1, d2); return Math.abs(v.dx) <= 1 && Math.abs(v.dy) <= 1 && (v.dx !== 0 || v.dy !== 0); }
            function isValidMove(lastDot, newDot) { if (currentPath.length < 2) return true; const prevDot = currentPath[currentPath.length - 2]; const angleDiff = calculateAngle(prevDot, lastDot, newDot); return angleDiff === 0 || angleDiff === 135; }
            function calculateAngle(p1, p2, p3) { const v1 = getVector(p1, p2); const v2 = getVector(p2, p3); const angle1 = getAngleFromVector(v1); const angle2 = getAngleFromVector(v2); let angleDiff = Math.abs(angle1 - angle2); if (angleDiff > 180) angleDiff = 360 - angleDiff; return Math.round(angleDiff); }
            function getVector(d1, d2) { return { dx: parseInt(d2.dataset.col) - parseInt(d1.dataset.col), dy: parseInt(d2.dataset.row) - parseInt(d1.dataset.row) }; }
            function getAngleFromVector(v) { return (Math.atan2(v.dy, v.dx) * 180 / Math.PI + 360) % 360; }
            function isDotInPath(d) { return currentPath.includes(d); }
            function drawLines() { lineCanvas.innerHTML = ''; if (currentPath.length < 2) return; const p = document.createElementNS('http://www.w3.org/2000/svg', 'polyline'); p.classList.add('line-user'); p.setAttribute('points', currentPath.map(d => `${d.offsetLeft + d.offsetWidth / 2},${d.offsetTop + d.offsetHeight / 2}`).join(' ')); lineCanvas.appendChild(p); }
            function highlightNextMoves() { dots.forEach(d => d.classList.remove('possible-move')); if (currentPath.length === 0 || !gameActive) return true; const lastDot = currentPath[currentPath.length - 1]; let possibleMovesCount = 0; dots.forEach(potentialNextDot => { if (isDotInPath(potentialNextDot) || !isAdjacent(lastDot, potentialNextDot)) return; if (isValidMove(lastDot, potentialNextDot) && !isCrossing(lastDot, potentialNextDot)) { potentialNextDot.classList.add('possible-move'); possibleMovesCount++; } }); return possibleMovesCount > 0; }
            
            // Event Listeners
            resetButton.addEventListener('click', resetGame);
            undoButton.addEventListener('click', undoMove);

            // Initialize Game
            initGrid();
            resetGame();
        });
    </script>
</body>
</html>
